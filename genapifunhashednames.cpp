#include <iostream>
#include <string>
#include <sstream>
#include <fstream>
#include <Windows.h>
#include <libloaderapi.h>

long pjwHash(char* s)
{
	unsigned long h = 0, high;
	while (*s)
	{
		h = (h << 4) + *s++;
		if (high = h & 0xF0000000)
			h ^= high >> 24;
		h &= ~high;
	}
	return h;
}

void genWinApiFunctionHash(std::fstream& logfile) {
	// Get project path location
	char buf[256];
	GetCurrentDirectoryA(256, buf);
	std::string projectPath = std::string(buf) + "\\";

	logfile << projectPath << "\n";

	HMODULE module = GetModuleHandleA("kernel32.dll");
	if (module == NULL) {
		logfile << "> CANNOT LOAD KERNEL32\n";
		return;
	}

	PIMAGE_OPTIONAL_HEADER poh = (PIMAGE_OPTIONAL_HEADER)((LPVOID)((SIZE_T)module + ((PIMAGE_DOS_HEADER)(module))->e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER)));
	PIMAGE_EXPORT_DIRECTORY exportDir = (IMAGE_EXPORT_DIRECTORY*)RVATOVA(module, poh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	int exportSize = poh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

	int ordinal = -1;

	DWORD * namesTable = (DWORD*)RVATOVA(module, exportDir->AddressOfNames);
	WORD * ordinalTable = (WORD*)RVATOVA(module, exportDir->AddressOfNameOrdinals);


	projectPath += "apifunhashed.hpp";
	std::fstream header_file;
	header_file.open(projectPath, std::fstream::out);

	header_file << "#ifndef _API_HASHES_H\n";
	header_file << "#define _API_HASHES_H\n\n";
	header_file << "// autogenerated from kernel32.dll\n\n";
	for (uint i = 0; i < exportDir->NumberOfNames; i++)
	{
		char* name = (char*)RVATOVA(module, *namesTable);
		long hashValue = pjwHash(name);

		header_file << "#define " << "hash" + std::string(name) << " " << hashValue << "\n";

		namesTable++;
		ordinalTable++;
	}
	header_file << "\n";
	header_file << "#endif // !_API_HASHES_H";
	header_file.close();
}